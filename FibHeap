#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Node structure of Fibonacci Heap
struct Node {
    int key;
    int degree;
    struct Node *parent;
    struct Node *child;
    struct Node *left;
    struct Node *right;
    int mark;
};

struct Node* minNode = NULL;

// Create a new Fibonacci Heap node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->degree = 0;
    newNode->parent = NULL;
    newNode->child = NULL;
    newNode->left = newNode;
    newNode->right = newNode;
    newNode->mark = 0;
    return newNode;
}

// Insert into Fibonacci Heap
void insert(int key) {
    struct Node* node = createNode(key);

    if (minNode == NULL) {
        minNode = node;
    } else {
        // Insert into root list
        node->right = minNode->right;
        node->left = minNode;
        minNode->right->left = node;
        minNode->right = node;

        if (node->key < minNode->key)
            minNode = node;
    }
}

// Merge two Fibonacci Heaps
void merge(struct Node* h2) {
    if (minNode == NULL)
        minNode = h2;
    else if (h2 != NULL) {
        // Join the circular doubly linked lists
        struct Node* temp = minNode->right;
        minNode->right = h2->right;
        h2->right->left = minNode;
        h2->right = temp;
        temp->left = h2;

        if (h2->key < minNode->key)
            minNode = h2;
    }
}

// Link two trees of same degree
void link(struct Node* y, struct Node* x) {
    y->left->right = y->right;
    y->right->left = y->left;

    y->parent = x;

    if (x->child == NULL) {
        y->left = y;
        y->right = y;
        x->child = y;
    } else {
        y->right = x->child->right;
        y->left = x->child;
        x->child->right->left = y;
        x->child->right = y;
    }

    x->degree++;
    y->mark = 0;
}

// Consolidate the heap after extract-min
void consolidate() {
    int maxDeg = 50;
    struct Node* A[maxDeg];
    for (int i = 0; i < maxDeg; i++)
        A[i] = NULL;

    struct Node* curr = minNode;
    if (curr == NULL) return;

    do {
        int d = curr->degree;
        while (A[d] != NULL) {
            struct Node* y = A[d];

            if (curr->key > y->key) {
                struct Node* temp = curr;
                curr = y;
                y = temp;
            }

            link(y, curr);
            A[d] = NULL;
            d++;
        }
        A[d] = curr;
        curr = curr->right;
    } while (curr != minNode);

    minNode = NULL;

    for (int i = 0; i < maxDeg; i++) {
        if (A[i] != NULL) {
            if (minNode == NULL)
                minNode = A[i];
            else {
                if (A[i]->key < minNode->key)
                    minNode = A[i];
            }
        }
    }
}

// Extract Minimum
int extractMin() {
    if (minNode == NULL)
        return -1;

    struct Node* z = minNode;

    if (z->child != NULL) {
        struct Node* c = z->child;
        do {
            struct Node* next = c->right;
            c->parent = NULL;

            // Add child to root list
            c->right = minNode->right;
            c->left = minNode;
            minNode->right->left = c;
            minNode->right = c;

            c = next;
        } while (c != z->child);
    }

    // Remove z from root list
    z->left->right = z->right;
    z->right->left = z->left;

    if (z == z->right) {
        minNode = NULL;
    } else {
        minNode = z->right;
        consolidate();
    }

    int minKey = z->key;
    free(z);
    return minKey;
}

int main() {
    insert(10);
    insert(3);
    insert(15);
    insert(6);

    printf("Minimum = %d\n", minNode->key);

    printf("Extracted Min = %d\n", extractMin());
    printf("New Minimum = %d\n", minNode->key);

    return 0;
}
